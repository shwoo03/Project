// Package report provides Markdown report generation.
package report

import (
	"fmt"
	"io"
	"strings"
	"time"
)

// MarkdownGenerator generates Markdown reports
type MarkdownGenerator struct {
	IncludeDetails bool
}

// Generate generates a Markdown report
func (g *MarkdownGenerator) Generate(report *Report, w io.Writer) error {
	var b strings.Builder

	// Title
	b.WriteString(fmt.Sprintf("# %s\n\n", report.Title))

	// Metadata
	b.WriteString(fmt.Sprintf("**Generated**: %s  \n", report.GeneratedAt.Format(time.RFC3339)))
	b.WriteString(fmt.Sprintf("**Target**: %s  \n", report.TargetURL))
	b.WriteString(fmt.Sprintf("**Version**: %s\n\n", report.Version))

	if report.Description != "" {
		b.WriteString(fmt.Sprintf("%s\n\n", report.Description))
	}

	// Summary
	b.WriteString("## ðŸ“Š Summary\n\n")
	b.WriteString("| Metric | Value |\n")
	b.WriteString("|--------|-------|\n")
	b.WriteString(fmt.Sprintf("| Total Requests | %d |\n", report.Statistics.TotalRequests))
	b.WriteString(fmt.Sprintf("| Success | %d |\n", report.Statistics.SuccessCount))
	b.WriteString(fmt.Sprintf("| Failures | %d |\n", report.Statistics.FailureCount))
	b.WriteString(fmt.Sprintf("| Timeouts | %d |\n", report.Statistics.TimeoutCount))
	b.WriteString(fmt.Sprintf("| Duration | %s |\n", report.Statistics.Duration.String()))
	b.WriteString(fmt.Sprintf("| RPS | %.2f |\n", report.Statistics.RequestsPerSec))
	b.WriteString(fmt.Sprintf("| Avg Response | %s |\n", report.Statistics.AvgResponseTime.String()))
	b.WriteString("\n")

	// Anomalies Summary
	b.WriteString("## ðŸ” Anomalies Found\n\n")
	b.WriteString(fmt.Sprintf("**Total**: %d\n\n", len(report.Anomalies)))

	if len(report.Anomalies) > 0 {
		// By Severity
		b.WriteString("### By Severity\n\n")
		b.WriteString("| Severity | Count |\n")
		b.WriteString("|----------|-------|\n")
		for _, sev := range []Severity{SeverityCritical, SeverityHigh, SeverityMedium, SeverityLow, SeverityInfo} {
			if count, ok := report.SeverityCounts[sev]; ok && count > 0 {
				b.WriteString(fmt.Sprintf("| %s | %d |\n", severityEmoji(sev), count))
			}
		}
		b.WriteString("\n")

		// Anomaly Details
		b.WriteString("### Details\n\n")

		for i, a := range report.Anomalies {
			b.WriteString(fmt.Sprintf("#### %d. %s %s\n\n", i+1, severityEmoji(a.Severity), a.Description))
			b.WriteString(fmt.Sprintf("- **Type**: %s\n", a.Type))
			b.WriteString(fmt.Sprintf("- **URL**: `%s`\n", a.URL))
			b.WriteString(fmt.Sprintf("- **Method**: %s\n", a.Method))
			if a.StatusCode > 0 {
				b.WriteString(fmt.Sprintf("- **Status Code**: %d\n", a.StatusCode))
			}
			if a.Payload != "" {
				b.WriteString(fmt.Sprintf("- **Payload**: `%s`\n", truncate(a.Payload, 100)))
			}
			b.WriteString(fmt.Sprintf("- **Time**: %s\n", a.Timestamp.Format(time.RFC3339)))

			if g.IncludeDetails && a.Response != "" {
				b.WriteString("\n**Response**:\n")
				b.WriteString("```\n")
				b.WriteString(truncate(a.Response, 500))
				b.WriteString("\n```\n")
			}
			b.WriteString("\n")
		}
	} else {
		b.WriteString("No anomalies detected. âœ…\n\n")
	}

	// Footer
	b.WriteString("---\n")
	b.WriteString("*Generated by FluxFuzzer*\n")

	_, err := io.WriteString(w, b.String())
	return err
}

// Extension returns the file extension
func (g *MarkdownGenerator) Extension() string {
	return "md"
}

// severityEmoji returns an emoji for the severity level
func severityEmoji(s Severity) string {
	switch s {
	case SeverityCritical:
		return "ðŸ”´ Critical"
	case SeverityHigh:
		return "ðŸŸ  High"
	case SeverityMedium:
		return "ðŸŸ¡ Medium"
	case SeverityLow:
		return "ðŸŸ¢ Low"
	case SeverityInfo:
		return "ðŸ”µ Info"
	default:
		return string(s)
	}
}

// truncate truncates a string to the given length
func truncate(s string, maxLen int) string {
	if len(s) <= maxLen {
		return s
	}
	return s[:maxLen] + "..."
}
